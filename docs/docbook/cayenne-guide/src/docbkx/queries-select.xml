<?xml version="1.0" encoding="UTF-8"?>
<!--
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements. See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to you under the Apache License, Version
    2.0 (the "License"); you may not use this file except in compliance
    with the License. You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0 Unless required by
    applicable law or agreed to in writing, software distributed under the
    License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
    CONDITIONS OF ANY KIND, either express or implied. See the License for
    the specific language governing permissions and limitations under the
    License.
-->
<section xmlns="http://docbook.org/ns/docbook" xml:id="selectquery">
    <title>ObjectSelect</title>
    <section>
        <title>Selecting objects</title>
        <para>
            <emphasis role="italic">ObjectSelect supersedes older SelectQuery. SelectQuery is still
                available and supported. </emphasis>
        </para>
        <para>ObjectSelect is the most commonly used query in Cayenne applications. This may be the
            only query you will ever need. It returns a list of persistent objects (or data rows) of
            a certain type specified in the
            query:
            <programlisting language="java">List&lt;Artist> objects = ObjectSelect.query(Artist.class).select(context);</programlisting>
            This returned all rows in the "ARTIST" table. If the logs were turned on, you might see the
            following SQL printed:
            <screen>INFO: SELECT t0.DATE_OF_BIRTH, t0.NAME, t0.ID FROM ARTIST t0
INFO: === returned 5 row. - took 5 ms.</screen>
        </para>
        <para>This SQL was generated by Cayenne from the ObjectSelect above. ObjectSelect can have a
            qualifier to select only the data matching specific criteria. Qualifier is simply an
            Expression (Expressions where discussed in the previous chapter), appended to the query
            using "where" method. If you only want artists whose name begins with 'Pablo', you might
            use the following qualifier expression:
            <programlisting language="java">List&lt;Artist> objects = ObjectSelect.query(Artist.class)
    .where(Artist.NAME.like("Pablo%"))
    .select(context);</programlisting>
            The SQL will look different this time:
            <screen>INFO: SELECT t0.DATE_OF_BIRTH, t0.NAME, t0.ID FROM ARTIST t0 WHERE t0.NAME LIKE ?
[bind: 1->NAME:'Pablo%']
INFO: === returned 1 row. - took 6 ms.</screen>
        </para>
        <para>ObjectSelect allows to assemble qualifier from parts, using "and" and "or" method to
            chain then together:
            <programlisting language="java">List&lt;Artist> objects = ObjectSelect.query(Artist.class)
    .where(Artist.NAME.like("A%"))
    .and(Artist.DATE_OF_BIRTH.gt(someDate)
    .select(context);</programlisting>
        </para>
        <para>To order the results of ObjectSelect, one or more orderings can be applied:
            <programlisting language="java">List&lt;Artist> objects = ObjectSelect.query(Artist.class)
    .orderBy(Artist.DATE_OF_BIRTH.desc())
    .orderBy(Artist.NAME.asc())
    .select(context);</programlisting>
        </para>
        <para>There's a number of other useful methods in ObjectSelect that define what to select
            and how to optimize database interaction (prefetching, caching, fetch offset and limit,
            pagination, etc.). Some of them are discussed in separate chapters on caching and
            performance optimization. Others are fairly self-explanatory. Please check the API docs
            for the full extent of the ObjectSelect features.
        </para>
    </section>
    <section>
        <title>Selecting individual columns</title>
        <para>
            <code>ObjectSelect</code> query can be used to fetch individual properties of objects via
            type-safe API:
            <programlisting language="java"><![CDATA[List<String> names = ObjectSelect.columnQuery(Artist.class, Artist.ARTIST_NAME)
    .select(context);]]></programlisting>
            And here is example of selecting several properties, note that result will be <code>Object[]</code>:
            <programlisting language="java"><![CDATA[List<Object[]> nameAndDate = ObjectSelect
    .columnQuery(Artist.class, Artist.ARTIST_NAME, Artist.DATE_OF_BIRTH)
    .select(context);]]></programlisting>
        </para>
    </section>
    <section>
        <title>Selecting using aggregate functions</title>
        <para>
            ObjectSelect query supports usage of aggregate functions.
            Most common variant of aggregation is selecting count of records, this can be done really easy:
            <programlisting language="java"><![CDATA[long count = ObjectSelect.query(Artist.class).selectCount(context);]]></programlisting>
            But you can use aggregates in more cases, even combine selecting individual properties and aggregates:
            <programlisting language="java"><![CDATA[// this is artificial property signaling that we want to get full object
Property<Artist> artistProperty = Property.createSelf(Artist.class);

List<Object[]> artistAndPaintingCount = ObjectSelect.columnQuery(Artist.class, artistProperty, Artist.PAINTING_ARRAY.count())
    .where(Artist.ARTIST_NAME.like("a%"))
    .having(Artist.PAINTING_ARRAY.count().lt(5L))
    .orderBy(Artist.PAINTING_ARRAY.count().desc(), Artist.ARTIST_NAME.asc())
    .select(context);

for(Object[] next : artistAndPaintingCount) {
    Artist artist = (Artist)next[0];
    long paintings = (Long)next[1];
    System.out.println(artist.getArtistName() + " have " + paintings + " paintings");
}]]></programlisting>
            Here is generated <code>SQL</code> for this query:
            <programlisting language="sql">SELECT DISTINCT t0.ARTIST_NAME, t0.DATE_OF_BIRTH, t0.ARTIST_ID, COUNT(t1.PAINTING_ID)
FROM ARTIST t0 JOIN PAINTING t1 ON (t0.ARTIST_ID = t1.ARTIST_ID)
WHERE t0.ARTIST_NAME LIKE ?
GROUP BY t0.ARTIST_NAME, t0.ARTIST_ID, t0.DATE_OF_BIRTH
HAVING COUNT(t1.PAINTING_ID) &lt; ?
ORDER BY COUNT(t1.PAINTING_ID) DESC, t0.ARTIST_NAME</programlisting>
        </para>
    </section>
</section>