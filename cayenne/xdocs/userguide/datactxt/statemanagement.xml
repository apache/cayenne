<document>
<title>User Guide - Using DataContext</title>
<toc name="toc-user-guide" chapter="6. Using DataContext"/>
<body>
    <section name="6. Using DataContext">
	<subsection name="6.3 DataObject State Management">
	
	<p>Second and most important function of DataContext (first being performing queries) is 
	keeping track of changes made to the registered DataObjects. Each object 
	should be registered with DataContext to become "persistent".</p>
	
	<subsection name="6.3.1 Registering DataObjects">
	<p>There are two ways for objects to get registered: (1) when they are fetched via query API and (2)
	explicitly for the newly created objects.</p>
	
	<p>Objects fetched via query API are registered automatically.
	DataContext takes a snapshot of each object's persistent properties and stores it internally 
	to be able to track later modifications to objects.
	</p>
	
	<p>Newly created objects must be registered with DataContext explicitly:</p>
	
<source>
import org.objectstyle.cayenne.access.DataContext;
...
DataContext ctxt; // assume this exists

// artist inherits from CayenneDataObject...
Artist artist = new Artist();

ctxt.registerNewObject(artist);

// after the line above is executed
// artist object aquired "persistent" behavior
// and is managed by DataContext
</source>

	<p>To reduce the amount of code needed to make new objects persistent, DataContext provides a 
	shortcut to create and register DataObjects in one method call. This requires a default no-argument 
	constructor in the DataObject class.</p>
<source>
import org.objectstyle.cayenne.access.DataContext;
...
DataContext ctxt; // assume this exists

Artist artist = (Artist)ctxt.createAndRegisterNewObject(Artist.class);
</source>
		</subsection>
		
		<subsection name="6.3.2 Checking the State of Registered DataObjects">
		<p>State transitions of DataObjects from persistence point of view are discussed in the
		"Design" chapter. State of each individual object is described by an integer
		constant obtained via a call to <code>DataObject.getPeristenceState()</code>
		Allowed states are defined as static variables in <a href=
		"../../api/cayenne/org/objectstyle/cayenne/PersistenceState.html">PersistenceState</a> class.</p>
		
		<p>When a new object is inserted to the DataContext as described above, it becomes "NEW":</p>
<source>
import org.objectstyle.cayenne.access.DataContext;
...
DataContext ctxt; // assume this exists

// artist will become PersistenceState.NEW
Artist artist = (Artist)ctxt.createAndRegisterNewObject(Artist.class);
</source>
		
		<p>When any of the attributes or relationships of the fetched or committed object are changed, such
		an object becomes MODIFIED:</p>
<source>
// assume this was fetched earlier
Artist artist;

// this will change the object state to PersistenceState.MODIFIED
artist.setName("NewName");
</source>

		<p>When a fetched or committed object is explicitly deleted from the DataContext, and object becomes DELETED:</p>
<source>
import org.objectstyle.cayenne.access.DataContext;
...
DataContext ctxt; // assume this exists

// assume this was fetched earlier
Artist artist;

// this will change the object state to PersistenceState.DELETED
ctxt.deleteObject(artist);
</source>

		<p>DataContext is said to have changes if it has one or more registered objects in a state
		<code>PersistenceState.MODIFIED</code>, <code>PersistenceState.NEW</code> or <code>PersistenceState.DELETED</code>.  
		DataContext provides the following method to check if it has any changed objects:
		
		<ul>
			<li><code>public boolean <b>hasChanges()</b></code></li>
		</ul>
		
		There is also a way to obtain a list of changed objects in each one of the above states:</p>
		
		<ul>
			<li><code>public java.util.Collection <b>newObjects</b>()</code></li>
			<li><code>public java.util.Collection <b>deletedObjects</b>()</code></li>
			<li><code>public java.util.Collection <b>modifiedObjects</b>()</code></li>
		</ul>
		</subsection>
		
		<subsection name="6.3.3 Committing All Modified DataObjects">
		<p>All of the objects with changes (what "changes" mean is discussed above) are committed to the
		database with a single method call on the DataContext:
		
		<ul>
			<li><code>public void <b>commitChanges()</b></code></li>
		</ul>
		
		Method <code>commitChanges</code> takes care of building correct SQL statements, generating primary
		keys and transactional behaviour. It roughly follows this scenario:
		
		<ul>
			<li>Checks if there are any changed objects.</li>
			<li>Checks if there are any NEW objects.</li>
			<li>Generates primary keys for any NEW objects that require autogenerated key.</li>
			<li>Builds any needed SELECT, UPDATE, DELETE queries.</li>
			<li>Starts the database transaction.</li>
			<li>Runs the queries.</li>
			<li>Commits transaction.</li>
			<li>Changes all committed objects state to PersistenceState.COMMITTED.</li>
			<li>Updates internally stored snapshots of the recently saved objects.</li>
		</ul>
		</p>
		</subsection>
		
	        <subsection name="6.3.3 Undoing All Uncommitted Changes">
	        <p>There is a way for the DataContext to undo all uncommitted changes:
	        <ul>
			<li><code>public void <b>rollbackChanges()</b></code></li>
		</ul>
		
		This will restore the persistence state and the values of all registered objects
		to the values that objects had when they were fetched or the last <code>commitChanges</code> 
		was executed. This effectively restores previously committed state of the object graph.
		Note that any NEW objects are unregistered from the context.		
	        </p>
		</subsection>
	</subsection>
    </section>
</body>
</document>
