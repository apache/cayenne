<document>
<title>User Guide - Using SelectQueries</title>
<toc name="toc-user-guide" chapter="7. Using Queries"/> 
<body>
    <section name="7. Using Queries"> 
        <subsection name="7.6 SQLTemplate Query">
            <p>Not all features of SQL can (or should) be mapped in the object model in terms of DataObjects. For such cases 
            Cayenne provides a powerful mechanism for running both selecting and non-selecting SQL using scriptable <a href=
            "../../api/cayenne/org/objectstyle/cayenne/query/SQLTemplate.html">SQLTemplate query</a>. This chapter 
            describes how simple SQLTemplates can be created and executed with DataContext to select or update
            the database data. Subsequent chapters show how to build SQL dynamically, bind parameters and describe result sets
            using SQLTemplate scripting features.</p> 
            
            <panel name="Note:">In Cayenne 1.0 executing SQL directly was done via SqlSelectQuery and SqlModifyQuery. 
            These classes didn't provide adequate support for building dynamic parameterized SQL, and are now deprecated
             in favor of SQLTemplate.
            </panel>
            
            <subsection name="7.6.1 Creating SQLTemplate">
            <p>While SQLTemplates can be built using CayenneModeler <i>[not there yet, coming soon...]</i>, creating them in
            the code is just as easy as regular SelectQueries. SQLTemplate consists of root and dynamic template string.
            Dynamic behavior of the template is discussed in subsequent chapters, for now it is sufficient to know that the template string 
            is simply a valid SQL statement in the target database SQL dialect. Note that one of the parameters in SQLTemplate constructor 
            is a boolean specifying whether the query is expected to return the result or not.
            </p>
<source>
import org.objectstyle.cayenne.query.SQLTemplate;
...
// create selecting SQLTemplate
SQLTemplate selectQuery = new SQLTemplate(Artist.class, "select * from ARTIST", true);
...
// create updating SQLTemplate
SQLTemplate updateQuery = new SQLTemplate(Artist.class, "delete from ARTIST", false);
</source>

		</subsection>
		<subsection name="7.6.2 Selecting Objects with SQLTemplate">

		<p>Selecting SQLTemplate is very similar to SelectQuery in many respects. It can be executed via <code>DataContext.performQuery(..)</code>
		and supports the same configuration parameters, such as fetch limit, pagination, etc. It can be configured to return DataObjects (default) 
		or data rows.</p>
<source>
import org.objectstyle.cayenne.query.SQLTemplate;
...
// fetch all artists, but no more than 1000 objects...
SQLTemplate rawSelect = new SQLTemplate(Artist.class, "select * from ARTIST", true);
rawSelect.setFetchLimit(1000);

List artists = dataContext.performQuery(rawSelect);
</source>
		</subsection>
		
		<subsection name="7.6.3 Modifying Data with SQLTemplate">
		<p>Non-selecting SQLTemplate allows to execute arbitrary SQL that modifies the database, but does not return the results.
		<code>DataContext.performNonSelectingQuery(..)</code> is used for this task.
		</p>
		<panel name="Important!">Developers making database changes via SQLTemplate must realize that these changes
		are done directly to the database, bypassing ObjectStore, and therefore may potentially leave object graph in an inconsistent state.
		</panel>
		<p> </p>
<source>
import org.objectstyle.cayenne.query.SQLTemplate;
...
// fetch all artists, but no more than 1000 objects...
SQLTemplate rawDelete = new SQLTemplate(Artist.class, "delete from ARTIST", false);
int[] deleteCounts = dataContext.performNonSelectingQuery(rawDelete);
</source>
	
		</subsection>
		
		<subsection name="7.6.4 Customizing SQL Dialects">
		<p>Even though SQL is an industry standard, different DB vendors still have their own dialects and
		extensions. Two versions of the same query written for Oracle and PostgreSQL may look quiet 
		different.</p>
		
		<p>Each SQLTemplate query has a default template, usually set in constructor. Internally it also keeps a map of alternative templates. 
		This map normally uses a fully-qualified class name of the target DbAdapter as a key. This way Cayenne can determine which one of the
		SQL strings to use during the execution. Alternative SQL strings are configured using <code>SQLTemplate.setTemplate(...)</code>: 
		</p>
		
<source>// build template with default SQL
SQLTemplate query = new SQLTemplate(Artist.class, "select * from ARTIST", true);

// for Postgres it would be nice to trim the CHAR ARTIST_NAME column 
// or otherwise it will be returned padded with spaces
String pgTemplate = "SELECT ARTIST_ID, RTRIM(ARTIST_NAME), DATE_OF_BIRTH FROM ARTIST";
query.setTemplate(PostgresAdapter.class.getName(), pgTemplate);
</source>
		</subsection>
        </subsection>
    </section>
</body>
</document>
